/**
 * @file RecorderTemplate.cpp
 * @author Philipp Holzmann (Philipp1990@web.de)
 * @brief 
 * @version 1.0
 * @date 2022-05-14
 * 
 * @copyright Copyright (c) 2022
 * 
 * This file ist generated by the f1GameParserGenerator Program. Any changes will be overriden.
 * 
 */
 

#include <Recorder_2021.h>
#include <DatabaseBuilder.h>
#include <UdpClient.h>
#include <F1DataEntity_2021.h>
#include <Exceptions/NothingRecivedException.h>
#include <RecordState.h>
#include <array>

namespace DogGE{
    namespace F1_2021{

        Recorder_2021::Recorder_2021(){

        }

        void Recorder_2021::setOutput(std::string output){
            this->mOutput = output;
        }

        void Recorder_2021::init(){
            mRecivedPackages = 0;
            mParsedPackages = 0;
            CTelemetry::Recorder::ProducerConsumerRecorder::init();
        }
        void Recorder_2021::producer(){
            DogGE::Network::UdpClient client;
            client.init("127.0.0.1","20777");
            do{
                try{
                    std::array<char,2000> buf = client.recvData<2000>();
                    mtx.lock();
                    this->mQueue.push(buf);
                    mtx.unlock();
                    mRecivedPackages++;
                } catch(DogGE::Network::NothingRecivedException &e){
                }
                
            } while(this->bRun);
        }
        void Recorder_2021::consumer(){
            this->mDatabase = DogGE::Database::DatabaseBuilder::fromMemory();
            F1DataEntity dummyEntity = F1DataEntity();
            DogGE::Database::PrepareStatement* createStatement = this->mDatabase->prepareStatement(dummyEntity.getTableDefinition());
            createStatement->execute();
            delete createStatement;
            DogGE::Database::PrepareStatement* insertStatement = this->mDatabase->prepareStatement("INSERT INTO F1DataEntity(`packetFormat`,`gameMajorVersion`,`gameMinorVersion`,`packetVersion`,`packetId`,`sessionUID`,`sessionTime`,`frameIdentifier`,`playerCarIndex`,`secondaryPlayerCarIndex`,`packet`) VALUES @packetFormat,@gameMajorVersion,@gameMinorVersion,@packetVersion,@packetId,@sessionUID,@sessionTime,@frameIdentifier,@playerCarIndex,@secondaryPlayerCarIndex,@packet");
            do{
                if(mQueue.size() == 0){
                    continue;
                }
                mtx.lock();
                std::array<char,2000> datagram = mQueue.front();
                mQueue.pop();
                mtx.unlock();
                F1DataEntity entity = F1DataEntity(datagram.data(),datagram.size());
                insertStatement->setIntParam(1,entity.getPacketFormat());
insertStatement->setIntParam(2,entity.getGameMajorVersion());
insertStatement->setIntParam(3,entity.getGameMinorVersion());
insertStatement->setIntParam(4,entity.getPacketVersion());
insertStatement->setIntParam(5,entity.getPacketId());
insertStatement->setInt64Param(6,entity.getSessionUID());
insertStatement->setFloatParam(7,entity.getSessionTime());
insertStatement->setIntParam(8,entity.getFrameIdentifier());
insertStatement->setIntParam(9,entity.getPlayerCarIndex());
insertStatement->setIntParam(10,entity.getSecondaryPlayerCarIndex());
insertStatement->setBlobParam(11,entity.getPacketData(),entity.getPacketSize());

                insertStatement->execute();
                insertStatement->resetParam();
                //this->mDatabase->persistData(&entity);
                mParsedPackages++;
                
            } while(this->bRun);
            delete insertStatement;
            DogGE::Database::DatabaseBuilder::convertMemoryIntoFile(this->mDatabase,this->mOutput);
            delete this->mDatabase;
            this->mDatabase = nullptr;
        }
        CTelemetry::Recorder::RecordState Recorder_2021::getState(){
            if(this->mDatabase != nullptr){
                DogGE::Database::DatabaseBuilder::convertMemoryIntoFile(this->mDatabase,this->mOutput);
            }
            
            int recivedPackages = this->mRecivedPackages;
            int parsedPackages = this->mParsedPackages;
            int queueSize = mQueue.size();
            this->mRecivedPackages = 0;
            this->mParsedPackages = 0;
            return CTelemetry::Recorder::RecordState(recivedPackages,parsedPackages,0,queueSize);
        }
    }
}                                                                                              