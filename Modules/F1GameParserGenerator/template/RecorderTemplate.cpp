/**
 * @file RecorderTemplate.cpp
 * @author Philipp Holzmann (Philipp1990@web.de)
 * @brief 
 * @version 1.0
 * @date 2022-05-14
 * 
 * @copyright Copyright (c) 2022
 * 
 * This file ist generated by the f1GameParserGenerator Program. Any changes will be overriden.
 * 
 */
 

#include <{{&HEADER_FILE}}>
#include <DatabaseBuilder.h>
#include <UdpClient.h>
{{&ADDITIONAL_INCLUDES}}
#include <Exceptions/NothingRecivedException.h>
#include <RecordState.h>
#include <array>

namespace DogGE{
    namespace {{&NAMESPACE_NAME}}{

        {{&CLASS_NAME}}::{{&CLASS_NAME}}(){

        }

        void {{&CLASS_NAME}}::setOutput(std::string output){
            this->mOutput = output;
        }

        void {{&CLASS_NAME}}::init(){
            mRecivedPackages = 0;
            mParsedPackages = 0;
            CTelemetry::Recorder::ProducerConsumerRecorder::init();
        }
        void {{&CLASS_NAME}}::producer(){
            DogGE::Network::UdpClient client;
            client.init("127.0.0.1","20777");
            do{
                try{
                    std::array<char,2000> buf = client.recvData<2000>();
                    mtx.lock();
                    this->mQueue.push(buf);
                    mtx.unlock();
                    mRecivedPackages++;
                } catch(DogGE::Network::NothingRecivedException &e){
                }
                
            } while(this->bRun);
        }
        void {{&CLASS_NAME}}::consumer(){
            this->mDatabase = DogGE::Database::DatabaseBuilder::fromMemory();
            {{&ENTITY_FILE_NAME}} dummyEntity = {{&ENTITY_FILE_NAME}}();
            DogGE::Database::PrepareStatement* createStatement = this->mDatabase->prepareStatement(dummyEntity.getTableDefinition());
            createStatement->execute();
            delete createStatement;
            DogGE::Database::PrepareStatement* insertStatement = this->mDatabase->prepareStatement("INSERT INTO {{&TABLE_NAME}}({{&TABLE_FIELD_NAMES}}) VALUES {{&TABLE_FIELD_VALUES}}");
            int packageNum = 2;
            do{
                mtx.lock();
                if(mQueue.size() < packageNum){
                    mtx.unlock();
                    continue;
                }
                mtx.unlock();

                for(int i=0; i < packageNum;i++){
                    mtx.lock();
                    std::array<char,2000> datagram = mQueue.front();
                    mQueue.pop();
                    mtx.unlock();
                    {{&ENTITY_FILE_NAME}} entity = {{&ENTITY_FILE_NAME}}(datagram.data(),datagram.size());
                    {{&FILL_INSERT_STMT}}
                }
                insertStatement->execute();
                insertStatement->resetParam();
                //this->mDatabase->persistData(&entity);
                mParsedPackages+=packageNum;
                
            } while(this->bRun);
            delete insertStatement;
            DogGE::Database::DatabaseBuilder::convertMemoryIntoFile(this->mDatabase,this->mOutput);
            delete this->mDatabase;
            this->mDatabase = nullptr;
        }
        CTelemetry::Recorder::RecordState {{&CLASS_NAME}}::getState(){
            
            if(this->mDatabase != nullptr){
                //DogGE::Database::DatabaseBuilder::convertMemoryIntoFile(this->mDatabase,this->mOutput);
            }
            
            int recivedPackages = this->mRecivedPackages;
            int parsedPackages = this->mParsedPackages;
            int queueSize = mQueue.size();
            this->mRecivedPackages = 0;
            this->mParsedPackages = 0;
            return CTelemetry::Recorder::RecordState(recivedPackages,parsedPackages,0,queueSize);
        }
    }
}